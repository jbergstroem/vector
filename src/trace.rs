use std::{
    marker::PhantomData,
    str::FromStr,
    sync::{
        atomic::{AtomicBool, Ordering},
        Mutex, MutexGuard,
    },
};

use metrics_tracing_context::MetricsLayer;
use once_cell::sync::OnceCell;
use tokio::sync::{
    broadcast::{self, Receiver, Sender},
    oneshot,
};
use tokio_stream::wrappers::BroadcastStream;
use tracing::{span::Span, Event, Subscriber};
pub use tracing_futures::Instrument;
use tracing_limit::RateLimitedLayer;
use tracing_subscriber::{
    layer::{Context, SubscriberExt},
    util::SubscriberInitExt,
    Layer,
};
pub use tracing_tower::{InstrumentableService, InstrumentedService};

use crate::event::LogEvent;

/// BUFFER contains all of the internal log events generated by Vector
/// before the topology has been initialized. It will be cleared (set to
/// `None`) by the topology initialization routines.
static BUFFER: OnceCell<Mutex<Option<Vec<LogEvent>>>> = OnceCell::new();

/// SHOULD_BUFFER controls whether or not internal log events should be buffered or sent directly to
/// the trace broadcast channel.
static SHOULD_BUFFER: AtomicBool = AtomicBool::new(true);

/// SUBSCRIBERS contains a list of callers interested in internal log events who will be notified
/// when early buffering is disabled, by receiving a copy of all buffered internal log events.
static SUBSCRIBERS: OnceCell<Mutex<Option<Vec<oneshot::Sender<Vec<LogEvent>>>>>> = OnceCell::new();

/// SENDER holds the sender/receiver handle that will receive a copy of
/// all the internal log events *after* the topology has been
/// initialized.
static SENDER: OnceCell<Sender<LogEvent>> = OnceCell::new();

fn metrics_layer_enabled() -> bool {
    !matches!(std::env::var("DISABLE_INTERNAL_METRICS_TRACING_INTEGRATION"), Ok(x) if x == "true")
}

pub fn init(color: bool, json: bool, levels: &str) {
    let _ = BUFFER.set(Mutex::new(Some(Vec::new())));
    let fmt_filter = tracing_subscriber::filter::Targets::from_str(levels).expect(
        "logging filter targets were not formatted correctly or did not specify a valid level",
    );

    let metrics_layer = metrics_layer_enabled()
        .then(|| MetricsLayer::new().with_filter(tracing_subscriber::filter::LevelFilter::INFO));

    let subscriber = tracing_subscriber::registry()
        .with(metrics_layer)
        .with(BroadcastLayer::new().with_filter(fmt_filter.clone()));

    #[cfg(feature = "tokio-console")]
    let subscriber = {
        let console_layer = console_subscriber::ConsoleLayer::builder()
            .with_default_env()
            .spawn();

        subscriber.with(console_layer)
    };

    if json {
        let formatter = tracing_subscriber::fmt::layer().json().flatten_event(true);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited = RateLimitedLayer::new(formatter);
        let subscriber = subscriber.with(rate_limited.with_filter(fmt_filter));

        let _ = subscriber.try_init();
    } else {
        let formatter = tracing_subscriber::fmt::layer()
            .with_ansi(color)
            .with_writer(std::io::stderr);

        #[cfg(test)]
        let formatter = formatter.with_test_writer();

        let rate_limited = RateLimitedLayer::new(formatter);
        let subscriber = subscriber.with(rate_limited.with_filter(fmt_filter));

        let _ = subscriber.try_init();
    }
}

#[cfg(test)]
pub fn reset_early_buffer() -> Option<Vec<LogEvent>> {
    get_early_buffer().replace(Vec::new())
}

fn get_early_buffer() -> MutexGuard<'static, Option<Vec<LogEvent>>> {
    BUFFER
        .get()
        .expect("Internal logs buffer not initialized")
        .lock()
        .expect("Couldn't acquire lock on internal logs buffer")
}

fn try_buffer_event(event: LogEvent) -> Option<LogEvent> {
    if SHOULD_BUFFER.load(Ordering::Acquire) {
        if let Some(buffer) = get_early_buffer().as_mut() {
            buffer.push(event);
            return None;
        }
    }

    Some(event)
}

fn consume_early_buffer() -> Vec<LogEvent> {
    get_early_buffer()
        .take()
        .expect("early buffer was already consumed")
}

/// Creates a trace sender for sending internal log events.
fn get_trace_sender() -> &'static broadcast::Sender<LogEvent> {
    SENDER.get_or_init(|| broadcast::channel(99).0)
}

/// Creates a trace receiver that receives internal log events.
fn get_trace_receiver() -> broadcast::Receiver<LogEvent> {
    get_trace_sender().subscribe()
}

fn get_trace_subscriber_list() -> MutexGuard<'static, Option<Vec<oneshot::Sender<Vec<LogEvent>>>>> {
    SUBSCRIBERS
        .get_or_init(|| Mutex::new(Some(Vec::new())))
        .lock()
        .expect("poisoned locks are dumb")
}

fn try_register_for_early_events() -> Option<oneshot::Receiver<Vec<LogEvent>>> {
    if SHOULD_BUFFER.load(Ordering::Acquire) {
        // We're still in early buffering mode. Attempt to subscribe by adding a oneshot sender
        // to SUBSCRIBERS. If it's already been consumed, then we've gotten beaten out by a
        // caller that is disabling early buffering, so we just go with the flow either way.
        get_trace_subscriber_list().as_mut().map(|subscribers| {
            let (tx, rx) = oneshot::channel();
            subscribers.push(tx);
            rx
        })
    } else {
        // Early buffering is being or has been disabled, so we can no longer register.
        None
    }
}

pub fn stop_buffering() {
    // First, consume any waiting subscribers. This causes new subscriptions to simply receive from
    // the broadcast channel, and not bother trying to receive the early buffered events.
    let subscribers = get_trace_subscriber_list().take();

    // Now that we have any waiting subscribers, actually disable early buffering and consume any
    // buffered log events. Once we have the buffered events, send them to each subscriber.
    SHOULD_BUFFER.store(false, Ordering::Release);
    let buffered_events = consume_early_buffer();
    for subscriber_tx in subscribers.into_iter().flatten() {
        // Ignore any errors sending since the caller may have dropped or something else.
        let _ = subscriber_tx.send(buffered_events.clone());
    }
}

/// Gets the current [`Span`].
pub fn current_span() -> Span {
    Span::current()
}

pub struct TraceSubscription {
    buffered_events_rx: Option<oneshot::Receiver<Vec<LogEvent>>>,
    trace_rx: Receiver<LogEvent>,
}

impl TraceSubscription {
    pub async fn buffered_events(&mut self) -> Option<Vec<LogEvent>> {
        // If we have a receiver for buffered events, and it returns them successfully, then pass
        // them back.  We don't care if the sender drops in the meantime, so just swallow that error.
        if let Some(rx) = self.buffered_events_rx.take() {
            if let Ok(events) = rx.await {
                return Some(events);
            }
        }

        None
    }

    pub fn into_stream(self) -> BroadcastStream<LogEvent> {
        BroadcastStream::new(self.trace_rx)
    }
}

pub fn subscribe() -> TraceSubscription {
    let buffered_events_rx = try_register_for_early_events();
    let trace_rx = get_trace_receiver();

    TraceSubscription {
        buffered_events_rx,
        trace_rx,
    }
}

struct BroadcastLayer<S> {
    _subscriber: PhantomData<S>,
}

impl<S> BroadcastLayer<S>
where
    S: Subscriber,
{
    fn new() -> Self {
        BroadcastLayer {
            _subscriber: PhantomData,
        }
    }
}

impl<S> Layer<S> for BroadcastLayer<S>
where
    S: Subscriber + 'static,
{
    fn on_event(&self, event: &Event<'_>, _ctx: Context<'_, S>) {
        // Try buffering the event, and if we're not buffering anymore, just send it along via the
        // trace sender.
        if let Some(event) = try_buffer_event(event.into()) {
            let _ = get_trace_sender().send(event.into());
        }
    }
}
